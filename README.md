# Slim для Bitrix

## Общая суть архитектуры решения.

По сути данный модуль является оберткой для API, то есть предполагается что низкоуровневая бизнес-логика уже реализована (средствами битрикса, либо другими средствами), а на этапе данного решения предполагается оборачивание функционала в API.

Точкой входа запросов является файл /api/slimbxapi.php (установочный файл dist/slimbxapi.php).
Требуется URL Rewrite, пример реврайта в dist/urlrewrite.example.php

Решение требует composer, файлы можно взять в папке dist/composer c учетом вашей версии php. Без установленного composer решщение работать не будет т.к. оснвано на фреймворке Slim.

По поводу неймспейсов. Фактически в проекте используются 2 автолоадера, первый -- композеровский, второй -- битриксовый (или наоборот, не важно). Но смысл в том, что без явного указания маппинга composer-реализация автолоадера классы приложения (по неймспейсу) подхватывать не будет. Но это и не нужно, потому что Bitrix-автолоадер их подхватывает, если модуль был установлен. Переходить на composer-реализацию autoloadre-а возможно имеет смысл на высоконагруженных проектах, если выяснится что это имеет свой результат. В противном случае все и так работает в таком виде.

Структура каталогов в папке модуля (lib)

 + **Controllers** контроллеры, точки входа бизнес-логики после резолвинга роутов, прямая аналогия с контроллерами MVC.
 + **Core** ядро модуля, служебный функционал.
 + **Enums** констатны-перечисления. На данном этапе используется для локальлизации. todo: обернуть в битриксовую локализацию.
 + **Exceptions** классы-исключений
 + **Helpers** хелперы, самостоятельно написанный вспомогательный функционал, либо обертки для битриксового функционала
 + **Middlewares** посредники, см. документацию https://www.slimframework.com/docs/v4/concepts/middleware.html
 + **routes** здесь находится статическая таблица роутов. В данном решении намеренно применена статическая таблица роутинга поскольку решение расчитывается версионирование API с одной стороны, с другой на небольшое и среднее количество API методов, по этим причинам статическая таблица роутов является при всей прямолинейности решения наиболее удобным.
 + **Services** тут находится оборачиваемая либо реализуемая логика. Предполагается что контроллеры тонкие и предназначаются для (опционально какой-то возможно первичной) валидации данных и вызове необходимого сервиса, который произведет полезную работу и вернет результат. Именно в сервисах и должно производиться оборачивание функционала Bitrix.


## Работа с ответами от сервера.

Для унификации и централизации присутствует класс-обертка для ответов от сервера, см lib/Core/ResponseBuilder.php


## Работа с ошибками.

Модуль придерживается следующей философии: **логическая ошибка может быть выброшена в любом слое бизнес-логики и должна быть централизованно перехвачена и транслирована в 400-й ответ**.

Реализовано это следующим способом: существует класс lib/Exceptions/LogicException.php который внутри lib/Core/ApiErrorHandler.php (который в свою очередь загружен на этпе инициализации фреймворка) обрабатывается таким образом, что в явном виде транслируется в унифицированный 400-й ответ сервера. То есть программисту по сути ничего выдумывать не надо, бросил LogicException и дальше за него уже все сделали.

Бывают ситуации когда нужно накопить ошибки и отдать несколько ошибок (например валидация формы). В этом случае выбросить LogicException можно позже, а для того чтобы программисту каждый раз не пришлось писать реализацию (временного) хранилища ошибок, есть класс lib/Core/ResponseErrors.php назначение которого аккумулировать ошибки в процессе работы скрипта и по необходимости вернуть их либо LogicException либо ResponseBuilder, и то и другое допустимо.


## Swagger

Ведется вручную. Заготовка dist/swagger. Необходимо скопировать по месту постоянного назначения swagger-а и начать вести его там.


## Прочее

Для корректной работы в корне проекта должет быть .env файл. ВСЕГДА проверяйте чтобы он был недоступен по http://server.name/.env поскольку в нем хранится секрет ключа авторизации.
Пример .env файла находится тут dist/.env.dist

После успешного разворачивания решения нужно зайти в swagger, там будет 2 тестовых метода, один для тестирования общей работоспособности (/test), другой для тестирования авторизации. Первый метод точно должен работать, если он не работает значит что-то не так развернулось.

После успешного разворачивания папку dist можно удалить.


## TODO

 + Написать автоматическое создание таблицы lib/ApiJwtTokensTable.php при установке модуля;
 + Автоматизировать установку/разветрывание (composer, slimbxapi, swagger);
 + Перейти с Emnum-ов на механизм локализации через адаптер не сломав интерфейс;